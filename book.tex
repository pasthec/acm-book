\documentclass[landscape,a4paper,twocolumn,10pt]{report}

% \usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{DejaVuSansMono}
\usepackage[usenames,dvipsnames]{color}
\usepackage{amsmath,amssymb,listings,array,fancyhdr,lastpage}
\usepackage[landscape,pdftex,top=1.5cm,bottom=0.1cm,left=0.475cm,right=0.475cm]{geometry}
\usepackage{tabularx}
\usepackage{xtab}
\usepackage{multirow}

\xentrystretch{-0.1}

\usepackage{pifont}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\lstset{
    language=C++,
    morekeywords={lli, llu, pii, piii, vi, vii, viii, vvi, vvii, vviii, pt, FOR, FORU, FORD},
    basicstyle=\ttfamily,
    keywordstyle=\color{blue}\ttfamily,
    stringstyle=\color{red}\ttfamily,
    commentstyle=\color{dkgreen}\ttfamily,
    morecomment=[l][\color{magenta}]{\#}
}

\setlength{\columnsep}{15pt}
\setlength{\columnseprule}{1pt}
\setlength{\headsep}{0.1cm}
\setlength{\footskip}{0cm}

\pagestyle{fancy}
\chead{\'Ecole Normale Sup\'erieure ULM}
\lhead{\textit{\small{}ENS Ulm 3}}
\rhead{\thepage{} of~\pageref{LastPage}}
\lfoot{}
\cfoot{}
\rfoot{}
\renewcommand{\headrulewidth}{0.1pt}
\renewcommand{\footrulewidth}{0pt}

\renewcommand{\line}{\noindent\rule{\linewidth}{1pt}}
\newcommand{\algosection}[1]{\line \subsection*{#1}}
\newcommand{\algorithm}[1]{\line \subsubsection*{#1}}

\begin{document}

\footnotesize

\noindent
Pre-contest: page \pageref{precontest} \\
Math: page \pageref{math} \\
String processing: page \pageref{string} \\
Data structures: page \pageref{datastruct} \\
Flows: page \pageref{flows} \\
Graphs: page \pageref{graphs} \\
Trees: page \pageref{trees} \\
Misc: page \pageref{misc} \\
Math formulas: page \pageref{mathformulas}

\algosection{Pre-contest}
\label{precontest}

%\algorithm{.vimrc}
%\lstinputlisting[language={}]{src/precontest/vimrc}

\algorithm{Constraints for 2s 1GHz processor and standard complexities}
$$
\begin{array}{|l|l||l|l|}
\hline
\mathbf{Comp.} & n & \mathbf{Comp.} & n \\
\hline
\hline
O(1) & 10^9 - 10^{18} & O(n \sqrt{n} \log n) & 5 \cdot 10^4 \\
\hline
O(\log n) & 10^9 - 10^{18} & O(\frac{n^2}{64}) & 5 \cdot 10^4 - 2 \cdot 10^5 \\
\hline
O(\log^{k} n), k \le 4 & 10^9 - 10^{18} & O(n^2)^{(\star \star)} & 10^4 \\
\hline
O(\sqrt{n}) & 10^9 - 10^{14} & O(n^2) & 3 \cdot 10^3 - 5 \cdot 10^3 \\
\hline
O(n)^{(\star)} & 10^7 - 10^8 & O(n^2 \log n) & 10^3 - 2 \cdot 10^3 \\
\hline
O(n \log \log n)^{(\star)} & 10^7 & O(n^3) & 300 - 500 \\
\hline
O(n) & 10^6 & O(n^k), k \le 6 & 40 - 50 \\
\hline
O(n \log n) & 3 \cdot 10^5 - 10^6 & O(2^{n/2} n) & 40 \\
\hline
O(n \log^{2} n) & 10^5 - 3 \cdot 10^5 & O(2^{n}) & 20 - 24 \\
\hline
O(n \sqrt{n}) & 2 \cdot 10^5 - 5 \cdot 10^5 & O(2^{n} n^k), k \le 3 & 16 - 20 \\
\hline
O(n \sqrt{n \log n}) & 10^5 & O(3^n) & 15 \\
\hline
\end{array}
$$
$(\star)$ — $n$ is not the size of input\quad $(\star \star)$ — without $O(n^2)$ memory

\algorithm{.bashrc}
\lstinputlisting[language=bash]{src/precontest/bashrc}

\algorithm{comp.sh}
\lstinputlisting[language=bash]{src/precontest/comp.sh}

\algorithm{mktests.sh}
\lstinputlisting[language=bash]{src/precontest/mktests.sh}

\algorithm{template.cpp}
\lstinputlisting{src/precontest/template.cpp}

\algosection{Math}
\label{math}

\algorithm{Extended GCD - $O(\log(\min(a, b)))$}
\lstinputlisting{src/math/egcd.cpp}

\algorithm{Inverse of $a$ modulo $m$ when $\operatorname{gcd}(a, m) = 1$ - $O(\log(\min(a, m)))$}
\lstinputlisting{src/math/invmod.cpp}

\algorithm{Inverses modulo $p$ of $\{1, \dots, N\}$ - $O(N)$}
\lstinputlisting{src/math/invmod_range.cpp}

\algorithm{Field $\mathbb F_p$ or group $\mathbb Z/p\mathbb Z$}
\lstinputlisting{src/math/Fp.cpp}

\algorithm{FFT / NTT / Polynomial multiplication - $O(n \log n)$}
\lstinputlisting{src/math/fft.cpp}

\algorithm{Utility to find NTT parameters}
\lstinputlisting[language=python]{src/math/findNTTParams.py}

\algorithm{Gauss - Solve linear system - Calculate matrix rank - $O(n^3)$}
\lstinputlisting{src/math/gauss.cpp}

\algorithm{Gauss in $\mathbb Z/2\mathbb Z$ - $O(n^3)$ (really good constant)}
\lstinputlisting{src/math/gauss_z2z.cpp}

\algorithm{Walsh-Hadamard transform - xor convolution - $O(n \log n)$}
\lstinputlisting{src/math/walsh_hadamard.cpp}

\algorithm{Subset sum transform - or convolution - $O(n \log n)$}
\lstinputlisting{src/math/subset_sum.cpp}

\algorithm{Modular operations on $\texttt{llu}$ (without overflow)}
\lstinputlisting{src/math/opmod.cpp}

\algorithm{Pollard's rho (number factorization) - $O(n^{\frac{1}{4}})$ in expectation}
\lstinputlisting{src/math/pollard_rho.cpp}

\algorithm{Miller-rabin (primality test) - $O(\log(n))$}
\lstinputlisting{src/math/miller_rabin.cpp}

\algorithm{Generate primes $< N$ - $O(N \log N)$}
\lstinputlisting{src/math/gen_primes.cpp}

\algorithm{Factorize numbers in $\{L, \dots, R\}$ - $O(\sqrt{R} + (R-L) \log(R))$}
\lstinputlisting{src/math/factorize_range.cpp}

\algorithm{Polynomial euclidian division - $O(|Q|(|P|-|Q|))$}
\lstinputlisting{src/math/polynom_euclid.cpp}

\algorithm{$n$th term of linear reccurence of order $k$ - $O(k^2 \log(n))$}
\lstinputlisting{src/math/linear_reccurence.cpp}

\algorithm{Fast square root on 64 bit integers - $O(1)$}
\lstinputlisting{src/math/fast_sqrt.cpp}

\algorithm{2d geometry}
\lstinputlisting{ut_src/2dgeometry.cpp}

\algosection{String processing}
\label{string}

\algorithm{KMP - $O(m+n)$}
\lstinputlisting{src/string/kmp.cpp}

\algorithm{Z function - $O(n)$}
\lstinputlisting{src/string/zfunc.cpp}

\algorithm{Aho-Corasick - linear}
\lstinputlisting{src/string/ahocorasick.cpp}

\algorithm{Suffix automaton - $O(n \Sigma)$}
\lstinputlisting{src/string/suffixautomaton.cpp}

\algorithm{Suffix array \& LCP - $O(n \log(n)^2)$}
\lstinputlisting{src/string/suffixarray.cpp}

\algorithm{Suffix array \& LCP using Suffix Automaton - $O(n \Sigma)$}
\lstinputlisting{src/string/suffixarray_linear.cpp}

\algorithm{Manacher - find all palindromes - $O(n)$}
\lstinputlisting{src/string/manacher.cpp}

\algorithm{Palindromic tree - $O(n)$}
\lstinputlisting{src/string/palindromic_tree.cpp}

\algorithm{String hash}
\lstinputlisting{ut_src/hash.cpp}

\algorithm{Minimum rotation - $O(n)$}
\lstinputlisting{src/string/min_rotation.cpp}

\algosection{Data structures}
\label{datastruct}

%\algorithm{Union-find - amortized $O(\log(n))$}
%\lstinputlisting{src/datastruct/unionfind.cpp}

\algorithm{Fenwick tree - $O(\log(n))$ add / get}
\lstinputlisting{src/datastruct/fenwick.cpp}

\algorithm{Fenwick tree with range update - $O(\log(n))$ add / addRange / get}
\lstinputlisting{src/datastruct/fenwick_range.cpp}

\algorithm{Segment tree - $O(\log(n))$ modify / inc / query}
\lstinputlisting{src/datastruct/segtree.cpp}

\algorithm{Lazy Segment tree - $O(\log(n))$ range add / query}
\lstinputlisting{src/datastruct/lazysegtree.cpp}

\algorithm{Treap - Augmentable binary search tree - $O(\log(n))$ insert / split / merge}
\lstinputlisting{src/datastruct/treap.cpp}

%\algorithm{Generic segment tree - Example of treap augmentation - $O(\log(n))$ insert / query / add}
%\lstinputlisting{src/datastruct/treap_gensegtree.cpp}

\algorithm{RMQ - $O(n \log n)$ initialization - $O(1)$ query}
\lstinputlisting{src/datastruct/rmq.cpp}

\algorithm{Wavelet Tree - build $O(n \log \Sigma)$ - activate/kth/rank/rankrange/swap $O(\log \Sigma)$ or $O(\log(\Sigma) \log(n))$}
\lstinputlisting{src/datastruct/wavelettree.cpp}

\algorithm{LogVector / Implicit Cartesian Tree - everything in $O(\log n)$}
\lstinputlisting{src/datastruct/logvector.cpp}

\algorithm{Convex hull trick}
\lstinputlisting{ut_src/cht.cpp}

\algorithm{Monotonic queue}
\lstinputlisting{ut_src/monotonic_queue.cpp}

\algosection{Flows}
\label{flows}

\algorithm{Common graph structure}
\lstinputlisting{src/flow/graph.cpp}

\algorithm{Dinic - $O(V^2 E)$}
\lstinputlisting{src/flow/dinic.cpp}

% \algorithm{Capacity Scaling - $O(E^2 \log(C))$ ($C$ = capacité max)}
% \lstinputlisting{src/flow/cap_scaling.cpp}

\algorithm{Min-cost max-flow}
\lstinputlisting{ut_src/mcmf.cpp}


\algosection{Graphs}
\label{graphs}

\algorithm{Strongly connected component Tarjan - $O(V + E)$}
\lstinputlisting{src/graph/scc_tarjan.cpp}

%\algorithm{Strongly connected component Kosaraju - $O(V + E)$}
%\lstinputlisting{src/graph/scc_kosaraju.cpp}

\algorithm{Articulation points / N\oe uds essentiels - $O(V + E)$}
\lstinputlisting{src/graph/articulation.cpp}

\algorithm{Bridges / Arcs essentiels - $O(V + E)$}
\lstinputlisting{src/graph/bridges.cpp}

\algorithm{Dominator Tree}
\lstinputlisting{src/graph/dominator_tree.cpp}

\algorithm{Directed minimum spanning tree}
\lstinputlisting{ut_src/dmst.cpp}

\algosection{Trees}
\label{trees}

\algorithm{LCA - $O(n \log n)$ preprocessing, $O(1)$ query}
\lstinputlisting{src/tree/lca.cpp}

\algorithm{Dynamic LCA - $O(\log n)$ add, $O(\log n)$ query}
\lstinputlisting{src/tree/lca_dyn.cpp}

\algorithm{Heavy-Light decomposition - $O(n)$ build, $O(\log n)$ LCA}
\lstinputlisting{src/tree/heavy_light.cpp}

\algorithm{Centroid decomposition - $O(n \log n)$ build}
\lstinputlisting{ut_src/centroid.cpp}


\algosection{Misc}
\label{misc}

\algorithm{LIS (Longest Increasing Subsequence) - $O(n \log n)$}
\lstinputlisting{src/misc/lis_full.cpp}

\algorithm{Size of LIS - $O(n \log n)$}
\lstinputlisting{src/misc/lis_short.cpp}

\algorithm{2-SAT - $O(n)$}
\lstinputlisting{ut_src/2sat.cpp}

\algorithm{Ternary search - $O(\log(b-a))$}
\lstinputlisting{ut_src/ternary_search.cpp}

\algosection{Math formulas}
\label{mathformulas}

\subsubsection*{Bernouilli numbers}

\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
\hline
$n$ & 0 & 1 & 2 & 4 & 6 & 8 & 10 & 12\\
\hline
$B_n$ & 1 & -1/2 & 1/6 & -1/30 & 1/42 & -1/30 & 5/66 & -691/2730 \\
\hline
\end{tabular}

\begin{tabular}{@{}ll@{}}
$B_{2n+3} = 0$
&
$(m+1) B_m = - \sum_{k=0}^{m-1}\binom{k}{m+1}B_k$
\\
$\sum_{k=1}^nk^m=\frac{1}{m+1}\sum_{k=0}^m\binom{m+1}{k}B_kn^{m+1-k}$
&
$n\geq 1$. $\zeta(2n) = (-1)^{n+1} \frac{B_{2n} (2\pi)^{2n}}{2(2n)!}$
\end{tabular}
\medskip

\subsubsection*{Integration}

\begin{tabular}{@{}ll|l@{}}
Method & Formula & Error term \\
\hline
Simpson's rule &
$\int_a^b f(x) \, dx \approx \frac{b-a}{6} (f(a) + 4 f(\frac{a+b}{2}) + f(b))$ &
$\frac{1}{90}\left(\frac{b-a}{2}\right)^5 \max_\xi |f^{(4)}(\xi)|$
\\

Gauss-Legendre 2 &
$\int_{-1}^1 f(x) \, dx \approx f(-\frac{1}{\sqrt{3}}) + f(\frac{1}{\sqrt{3}})$ &
$\frac{1}{135} \max_\xi |f^{(4)}(\xi)|$
\end{tabular}

\noindent Total accumulated error: $O(h^4)$

\subsubsection*{Runge-Kutta method to approximate $y'=f(x,y)$ with step $h$}
$\begin{aligned}
y_{n+1} &= y_n + \tfrac{h}{6}\left(k_1 + 2k_2 + 2k_3 + k_4 \right),\\
t_{n+1} &= t_n + h \\
\end{aligned}
\hspace{0.5cm} \mbox{with} \hspace{0.5cm}
\begin{aligned}
 k_1 &= f(t_n, y_n), \\
 k_2 &= f\left(t_n + \frac{h}{2}, y_n + \frac{h}{2}k_1\right), \\
 k_3 &= f\left(t_n + \frac{h}{2}, y_n + \frac{h}{2}k_2\right), \\
 k_4 &= f\left(t_n + h, y_n + h k_3\right).
\end{aligned}
$


\subsubsection*{Triangle geometry / Pick theorem}

$p=\frac{a+b+c}{2}$.\\
Area: $A=\frac{\sin\alpha}{a}=\sqrt{p(p-a)(p-b)(p-c)}$.\\
Incircle: $r=\frac{A}{p}$. $I=\frac{a}{2p}A+\frac{b}{2p}B+\frac{c}{2p}C$.\\
Length of the angle bissector through $A$: $i_a=\frac{2}{b+c}\sqrt{p(p-a)bc}$.\\
Circumcircle: $R=\frac{abc}{4A}=\frac{a}{2\sin\alpha}$. $O=\frac{1}{\sin(2\alpha)+\sin(2\beta)+\sin(2\gamma)}(\sin(2\alpha)A+\sin(2\beta)B+\sin(2\gamma)C)$.\\
Orthocenter: $H=\frac{1}{\tan\alpha+\tan\beta+\tan\gamma}(\tan(\alpha)A+\tan(\beta)B+\tan(\gamma)C)$.\\
Law of cosines: $c^2=a^2+b^2-2ab\cos(\gamma)$.

\noindent Pick's theorem: $A=I+\frac{1}{2}B-1$. ($A$ area polygon, $I$ number of interior points, $B$ number of boundary points).


\subsubsection*{Asymptotics}

\noindent
Number of divisors of $n$: $d(n) = O(n^{1/3})$ (in practice) \\ % http://codeforces.com/blog/entry/651 (use translate.yandex.com )
Number of partitions of $n$ elements: $p(n) \sim \frac{1}{4 n \sqrt{3}} \exp(\pi \sqrt{\frac{2n}{3}})$ \\ % from wikipedia
$n! \sim \sqrt{2 \pi n} n^n e^{-n}$ \\ % Stirling's approximation
$\binom{2n}{n} \sim \frac{4^n}{\sqrt{\pi n}}$


% What follows is adapted from https://github.com/niklasb/tcr/blob/master/tcr.pdf

\subsubsection*{Number Theory}
\begin{center}
\begin{tabular}{@{}l|l@{}}
exp of $p$ in $n!$ is $\sum_{i\ge 1}[\frac{n}{p^i}]$
\\
$p_n \sim n\log n$; $\pi(x) \sim \frac{x}{\log x}$ &
\quad $\forall_{n>1} \exists_{n<p<2n}: p$ is prime
\\
$a\equiv b$ $($mod $x,y)\Rightarrow a\equiv b$ $($mod lcm$(x,y))$ & $ac\equiv bc$ $($mod $m)\Rightarrow a\equiv b ($mod $\frac{m}{\gcd(c,m)})$ \\
$p$ prime $\Leftrightarrow (p-1)! \equiv -1 (\%p)$ &
Carmichael function $\lambda(n)$ minimal st. $\forall_a, a^{\lambda(n)} \equiv 1(\%n)$ % https://en.wikipedia.org/wiki/Carmichael_function
\\
\multicolumn{2}{l}{$\lambda(2^t)=2^{t-2}$, $\lambda(p^t)=(p-1)p^{t-1}$, $\lambda(2^{t_0}p_1^{t_1}\cdots p_m^{t_m})=lcm(\lambda(2^{t0}),\phi(p_1^{t_1}),\cdots,\phi(p_m^{t_m}))$}
\\
$\phi(p_1^{e_1}) \cdots p_m^{e_m}) = (p_1^{e_1} - p_1^{e_1-1}) \cdots (p_m^{e_m} - p_m^{e_m-1})$ &
$a \perp m \Rightarrow a^{\phi(m)}=1 (\%m)$
\\
$\sum_{d|n}\phi(d)=n$ &
$\sum_{m\perp n,m<n}m=\frac{n\phi(n)}{2}$
\\
$r$ p\_root of $n$ $\Leftrightarrow$ $\mathrm{ord}_n(r) = \phi(n)$ &
$r$ p\_root of $n$, then $r^u$ is p\_root of $n \Leftrightarrow u\perp\phi(n)$
\\
$n$ has p\_roots $\Leftrightarrow n=1,2,4,p^t,2p^t$ ($p$ odd prime) & % https://oeis.org/A033948
$n$ has p\_roots $\Leftrightarrow n$ has $\phi(\phi(n))$ p\_roots
\\
$r=\mathrm{ord}_n(a)$, $\mathrm{ord}_n(a^u)= \frac{r}{\gcd(r,u)}$ & % https://en.wikipedia.org/wiki/Order_(group_theory)
$[\sqrt{n}]$  Newton: $y=[\frac{x+[n/x]}{2}]$, $x_0=2^{[\frac{\log_2(n)+2}{2}]}$
\\
$\mu(p_1p_2\cdots p_s)=(-1)^s$, else $0$ &
$\sum_{d|n}\mu(d)=1$ if $n=1$, else $0$
\\
$F(n)=\sum_{d|n}f(d)\Leftrightarrow f(n)=\sum_{d|n}\mu(d)F(\frac{n}{d})$ &
$\sigma_x(n) = \sum_{d|n} d^x$
\\
$\sigma_0(p_1^{e_1}\cdots p_s^{e_s}) = \prod_{i=1}^s(e_i+1)$ &
$\sigma_x(p_1^{e_1}\cdots p_s^{e_s}) = \prod_{i=1}^s \frac{p_i^{(e_i+1)x}-1}{p_i^x-1} = \prod_{i=1}^s \sum_{j=0}^{e_i} p_i^{jx}$
\\
\end{tabular}
\end{center}


\subsubsection*{Combinatorics}

\begin{center}
\begin{tabular}{@{}ll@{}}
HanoiTower(HT) min steps & $T_n = 2^n - 1$ \\
HanoiTower (no direct $A$ to $C$) & $T_n = 3^n - 1$ \\
HT min steps A to C clockw.& $Q_n=2R_{n-1}+1$ \\
HT min steps C to A clockw.& $R_n=2R_{n-1}+Q_{n-1}+2$ \\
Egyptian Fraction & $\frac{m}{n}=\frac{1}{\lceil n/m \rceil}+(\frac{m}{n}-\frac{1}{\lceil n/m \rceil})$ \\
\#labeled rooted trees & $n^{n-1}$ \\
\#labeled unrooted trees & $n^{n-2}$ \\
\#SpanningTree of $G$ (no SL) & $C(G)=D(G)-A(G)(\downarrow)$ \\
$D:$ DegMat; $A:$ AdjMat & $Ans=|\det(C-1r-1c)|$ \\
\#heaps of a tree (keys: $1..n$) & $\frac{(n-1)!}{\prod_{i\neq root} \mathrm{size}(i)}$ \\
\#ways $0\rightarrow m$ in $n$ steps (never $<0$) & $\frac{m+1}{\tfrac{n+m}2+1}\binom{n}{\tfrac{n+m}2}$ \\
\multicolumn{2}{l}{$\#seq\langle a_0,...,a_{mn} \rangle$ of $1$'s and $(1-m)$'s with sum $+1 = \binom{mn+1}{n}\frac{1}{mn+1}=\binom{mn}{n}\frac{1}{(m-1)n+1}$ } \\
\end{tabular}
\end{center}

\subsubsection*{Famous numbers in combinatorics}

\begin{center}
\begin{tabular}{@{}l|l@{}}
Catalan & \multirow{2}{*}{$C_0=1$, $C_n=\frac{1}{n+1}\binom{2n}{n} = \sum_{i=0}^{n-1}C_iC_{n-i-1} = \frac{4n-2}{n+1}C_{n-1}$} \\
\# $2n$ parenthesis correctly matched & \\
Stirling 1st kind & \multirow{2}{*}{$\left[{0\atop 0}\right]=1$, $\left[{n\atop 0}\right]=\left[{0\atop n}\right]=0$, $\left[{n\atop k}\right]=(n-1)\left[{n-1\atop k}\right]+\left[{n-1\atop k-1}\right]$} \\
\#perms of $n$ objs with exactly $k$ cycles & \\ % https://en.wikipedia.org/wiki/Stirling_numbers_of_the_first_kind
Stirling 2nd kind & \multirow{2}{*}{$\left\{{n\atop 1}\right\}=\left\{{n\atop n}\right\}=1$, $\left\{{n\atop k}\right\} = k \left\{{ n-1 \atop k }\right\} + \left\{{n-1\atop k-1}\right\}$} \\
\#ways to partition $n$ objs into $k$ nonempty sets & \\ % https://en.wikipedia.org/wiki/Stirling_numbers_of_the_second_kind
Euler & \multirow{2}{*}{$\left \langle {n\atop 0} \right \rangle = \left \langle {n\atop n-1} \right \rangle = 1 $, $\left \langle {n\atop k} \right \rangle = (k+1) \left \langle {n-1\atop {k}} \right \rangle + (n-k)\left \langle {{n-1}\atop {k-1}} \right \rangle$} \\
\#perms of $n$ objs with exactly $k$ ascents & \\ % https://en.wikipedia.org/wiki/Eulerian_number
Euler 2nd Order & \multirow{2}{*}{$\left \langle \!\!\left \langle {n\atop k} \right \rangle \!\! \right \rangle = (k+1) \left \langle \!\! \left \langle {{n-1}\atop {k}} \right \rangle \!\! \right \rangle +(2n-k-1)\left \langle \!\! \left \langle {{n-1}\atop {k-1}} \right \rangle \!\! \right \rangle$} \\
\#perms of ${1,1,...,n,n}$ with exactly $k$ ascents & \\ % https://en.wikipedia.org/wiki/Eulerian_number
Bell & \multirow{2}{*}{$B_1 = 1$, $B_n = \sum_{k=0}^{n-1} B_k \binom{n-1}{k} = \sum_{k=0}^n\left\{{n\atop k}\right\}$} \\
\#partitions of $1..n$ (Stirling 2nd, no limit on k) & \\
Partition\_k & $p_0(0) = 1$, $p_k(n) = p_k(n-k) + p_{k-1}(n-1)$ \\
\#partitions of $1..n$ in $k$ parts up to permutation & = \#partitions of $1..n$ with parts $\leq k$ (up to permutation)\\
\end{tabular}
\end{center}

\subsubsection*{Putting balls in boxes}

% https://en.wikipedia.org/wiki/Twelvefold_way
\begin{center}
\begin{tabular}{@{}c|c|c|c|c||c@{}}
Balls & same & distinct & same & distinct & \multirow{2}{*}{Remarks} \\
Boxes & same & same & distinct & distinct & \\
\hline
-          & $\mathrm{p}_k(n+k)$ & $\sum_{i=0}^k \left\{{n\atop i}\right\}$ & $\binom{n+k-1}{n}$ & $k^n$ &
\multirow{3}{*}{\parbox[t]{5cm}{$[cond]$: $1$ if $cond=true$, else $0$ \\ same = we count up to permutation \\ inj/surj is for the function ball $\to$ boxes}} \\
injective  & $[n \le k]$         & $[n \le k]$                              & $\binom{k}{n}$     & $n!\binom{k}{n}$ & \\
surjective & $\mathrm{p}_k(n)$   & $\left\{{n\atop k}\right\}$              & $\binom{n-1}{k-1}$ & $k!\left\{{n\atop k}\right\}$ & \\
\end{tabular}
\end{center}

\subsubsection*{Ballot problem}

% http://webspace.ship.edu/msrenault/ballotproblem/
\begin{center}
\begin{tabular}{@{}ll||l@{}}
Always $\#A > k\#B$ & $Pr=\frac{a-kb}{a+b}$ &
\multirow{2}{*}{\parbox[t]{7cm}{A has $a$ votes and B has $b$ votes. During the counting, we want to know if A was always ahead of B (when $k=1$). Generalization with any $k$.}} \\
Always $\#A \ge k\#B$ & $Pr=\frac{a+1-kb}{a+1}$ & \\
\end{tabular}
\end{center}

\subsubsection*{Farey sequence}

\noindent
$F^{(n)} = $ sequence of reduced fractions in $[0,1]$ with denominator $<= n$, in increasing order. \\
Starts with $1/0$, ends with $1/1$. $|F^{(n)}| \sim \frac{3n^2}{\pi^2}$.
Suppose that $\frac{p_{k-1}}{q_{k-1}}, \frac{p_{k}}{q_{k}}, \frac{p_{k+1}}{q_{k+1}}$ are 3 consecutive terms in $F^{(n)}$. \\
Then $\frac{p_k}{q_k} = \frac{p_{k-1} + p_{k+1}}{q_{k-1} + q_{k+1}}$ \\
and $p_{k+1} = \left\lfloor \frac{n+q_{k-1}}{q_k} \right\rfloor p_k - p_{k-1}$ and  $q_{k+1} = \left\lfloor \frac{n+q_{k-1}}{q_k} \right\rfloor q_k - q_{k-1}$ \\
and $\frac{p_{k+1}}{q_{k+1}} - \frac{p_k}{q_k} = \frac{1}{q_k q_{k+1}}$

\subsubsection*{Game Theory}

Sprague-Grundy theorem hypothesis: the game is impartial, each player have the same set of moves, a player that can't move loses.
To calculate the SG number:
\begin{itemize}
    \item The SG number of the sum two games with numbers $SG_1$ and $SG_2$ is $SG_1 \oplus SG_2$
    \item The SG number of a game is $\mathrm{mex} \; S$ where $S$ is the set of SG numbers of the games you can move to, and $\mathrm{mex} \; S = \mathrm{min} \; \mathbb{N} \setminus S$
    \item The first player has a winning strategy $\Leftrightarrow$ the SG number of the game is $\neq 0$
\end{itemize}

\begin{xtabular}{p{1.5cm}|p{4cm}|p{7cm}}
\multicolumn{3}{c}{Classical Games (\ding{182} last one wins (normal); \ding{183} last one loses (mis\`ere))} \\ \hline
Name & Description & Criteria / Opt.strategy \\ \hline

NIM &
$n$ piles of objs. One can take any number of objs from any pile (i.e. set of possible moves for the $i$-th pile is $M=[pile_i]$, $[x]:=\{1,2,...,\lfloor x \rfloor\}$). &
$SG=\otimes_{i=1}^n pile_i$. Strategy: \ding{182} make the Nim-Sum 0 by \emph{decreasing} a heap; \ding{183} the same, except when the normal move would only leave heaps of size 1. In that case, leave an odd number of 1's.
The result of \ding{183} is the same as \ding{182}, opposite if all piles are 1's. Many games are essentially NIM.
\\ \hline

NIM (powers) &
$M = \{a^m|m\ge 0\}$&
If $a$ odd: $SG_n = n \% 2$
If $a$ even: $SG_n = 2$, if $n\equiv a\%(a+1)$; $SG_n = n \% (a+1) \% 2$, else.
\\ \hline

NIM (half) &
$M_{\text{\ding{172}}} = [\frac{pile_i}{2}]$ \newline $M_{\text{\ding{173}}} = [\lceil \frac{pile_i}{2} \rceil\text{, } pile_i]$ &
\ding{172}$SG_{2n} = n$, $SG_{2n+1}=SG_{n}$ \newline \ding{173}$SG_0=0$, $SG_n=[\log_2 n]+1$
\\ \hline

NIM (divisors) &
$M_{\text{\ding{172}}} = \text{divisors of } pile_i$ \newline $M_{\text{\ding{173}}} = \text{proper divisors of }pile_i$ &
\ding{172}$SG_0 = 0$, $SG_n = SG_{\text{\ding{173}},n} + 1$ \newline \ding{173}$SG_1=0$, $SG_n=$ number of 0's at the end of $n_{binary}$
\\ \hline

Subtraction Game &
$M_{\text{\ding{172}}} = [k]$ $M_{\text{\ding{173}}} = S$ (finite) $M_{\text{\ding{174}}} = S \cup \{pile_i\}$ &
$SG_{\text{\ding{172}},n} = n \mod (k+1)$. \ding{182}lose if $SG=0$; \ding{183}lose if $SG=1$. $SG_{\text{\ding{174}},n} = SG_{\text{\ding{173}},n}+1$
For any finite $M$, $SG$ of one pile is eventually periodic.
\\ \hline

Moore's NIM$_k$ &
One can take any number of objs from at most k piles. &
\ding{182}Write $pile_i$ in base $k+1$, sum up each digit without carry. Losing if the result is 0.
\ding{183} If all piles are 1's, losing iff $n\equiv 1\%(k+1)$. Otherwise the result is the same as \ding{182}.
\\ \hline

Staircase NIM &
$n$ piles in a line. One can take any number of objs from $pile_i$, $i>0$ to $pile_{i-1}$ &
Losing if the NIM formed by the odd-indexed piles is losing(i.e. $\otimes_{i=0}^{(n-1)/2} pile_{2i+1}=0$)
\\ \hline

Lasker's NIM &
Two possible moves: 1.take any number of objs; 2.split a pile into two (no obj removed) &
$SG_n = n, \text{ if }n\equiv 1,2(\% 4)$ $SG_n = n+1, \text{ if }n\equiv3(\% 4)$ $SG_n = n-1, \text{ if }n\equiv0(\% 4)$
\\ \hline

Kayles &
Two possible moves: 1.take 1 or 2 objs; 2.split a pile into two (after removing objs) &
$SG_n$ for small $n$ can be computed recursively. $SG_n$ for $n \in [72,83]$: 4 1 2 8 1 4 7 2 1 8 2 7
$SG_n$ becomes periodic from the 72-th item with period length 12.
\\ \hline

Dawson's Chess &
$n$ boxes in a line. One can occupy a box if its neighbours are not occupied. &
$SG_n$ for $n\in [1,18]$: 1 1 2 0 3 1 1 0 3 3 2 2 4 0 5 2 2 3
Period = 34 from the 52-th item.
\\ \hline

Wythoff's Game
& \textbf{Two} piles of objs. One can take any number of objs from either pile, or take the \emph{same} number from \emph{both} piles. &
$n_k = \lfloor k \phi \rfloor = \lfloor m_k \phi \rfloor -m_k$  $m_k = \lfloor k \phi^2 \rfloor = \lceil n_k \phi \rceil = n_k + k$  $\phi:=\frac{1+\sqrt{5}}{2}$. $(n_k,m_k)$ is the $k$-th losing position.
$n_k$ and $m_k$ form a pair of complementary Beatty Sequences (since$\frac{1}{\phi}+\frac{1}{\phi^2}=1$). Every $x>0$ appears either in $n_k$ or in $m_k$.
\\ \hline

Mock Turtles &
$n$ coins in a line. One can turn over 1, 2 or 3 coins, with the rightmost from head to tail. &
$SG_n = 2n$, if $\mathrm{ones}(2n)$ odd; $SG_n = 2n + 1$, else. $\mathrm{ones}(x)$: the number of 1's in $x_{binary}$
$SG_n$ for $n\in [0,10]$ (leftmost position is 0): 1 2 4 7 8 11 13 14 16 19 21
\\ \hline

Ruler &
$n$ coins in a line. One can turn over any \emph{consecutive} coins, with the rightmost from head to tail. &
$SG_n=$ the largest power of 2 dividing $n$. This is implemented as $n$\&$-n$(lowbit)
$SG_n$ for $n\in [1,10]$: 1 2 1 4 1 2 1 8 1 2
\\ \hline

Divisors &
You have a number $n$. One can divide it at each turn. &
$SG_n=$ number of prime factors of $n$
\\ \hline

\end{xtabular}

{\bf Burnside's Lemma:} $L=\frac{1}{|G|}\sum_{k=1}^n|Z_k|=\frac{1}{|G|}\sum_{a_i \in G}C_1(a_i)$. $Z_k:$ the set of permutations in $G$ under which $k$ stays stable; $C_1(a_i):$ the number of cycles of order $1$ in $a_i$. \quad {\bf P\'olya's Theorem:} The number of colorings of $n$ objects with $m$ colors $L=\frac{1}{|\overline{G}|}\sum_{g_i \in \overline{G}}{m^{c(g_i)}}$. $\overline{G}:$ the group over $n$ objects; $c(g_i):$the number of cycles in $g_i$.

\textbf{Exponential families (unlabelled)}: $h(n) =$ number of possible hands of weight $n$,
$h(n,k) =$ number of hands of weight $n$ with $k$ cards, $d(n) =$ number of cards of weight n.
Then $k \cdot h(n, k) = \sum_{r, m \ge 1} h(n - rm, k - m)\cdot d(r)$ and
$n \cdot h(n) = \sum_{m \ge 1} h(n - m) \cdot \sum_{r | m} r\cdot d(r)$.

\begin{itemize}
\item Johnson's Reweighting Algorithm: add a new source S, it can reach all other nodes with 0 cost. Use bellmanford to calculate the shortest path d[i] from S to all other nodes i. Exit when negative cycle is found. Otherwise the weights of all edges (u,v) in the original graph are changed to d[u]+w[u,v]-d[v]. Now all weights are nonnegative, so dijkstra algorithm can be used.
\item feasible flow in a network with both upper and lower capacity constraints, no source or sink : capacity are changed to upperbound-lowerbound. Add a new source and a sink. let M[v] = (sum of lowerbounds of ingoing edges to v) - (sum of lowserbounds of outgoing edges from v). For all v, if M[v]>0 then add edge (S,v) with capacity M, otherwise add (v,T) with capacity -M. If all outgoing edges from S are full, then a feasible flow exists, it is the flow plus the original lowerbounds.
\item feasible flow in a network with both upper and lower capacity constraints, with source s and sink t: add edge (t,s) with capacity infinity. Binary search for the lower bound, check whether a feasible exists for a network WITHOUT source or sink (B).
\item system of difference constraints: change all the conditions to the form a-b<=c. For every such condition add an edge (b,a) with weight c. Add a source which can reach all the nodes with 0 cost. Find shortest paths with bellman ford from s. d[v] is a solution.
\item min-weight vertex cover in a bipartite graph: partition into A and B. add edges $s \rightarrow A$ with capacities $w(A)$ and edges $B \rightarrow t$ with capacities $w(B)$. add edges of capacity $\infty$ from A to B where there are edges in the graph. answer is maxflow. the vertex cover is the set of nodes that are
adjacent to cut edges, or alternatively, the left-side nodes NOT reachable from the source and the right-side edges reachable from the source (in the residual network).
\item Bipartite Graph: Min Cover (fewest nodes cover all edges) = max matching. Min path covering for DAG: n - maxmatching. Min dominating set = max matching + isolated nodes. Max independent set = n - max matching
\item Bipartite matching with weights on the left-hand nodes, minimizing the matched weight sum:
   sort left-hand nodes ascending by weight, then just use the normal bipartite matching algorithm (Kuhn's)
\item Closure problem: Find a subset $V' \subset V$ such that $V'$ is closed (every successor of a node in $V'$ is also in $V'$) and such that $\sum_{v \in V'} w(v)$ is maximal under all such subsets $V'$. We use min-cut: for every node $v$, if $w(v) > 0$, add an edge $(S, v)$ with capacity $w(v)$, otherwise add edge $(v,T)$ with capacity $-w(v)$. Add edges $(v,w)$ with capacity $\infty$ for all edges $(v,w)$ in the original graph. The source partition of the min-cut is the optimal $V'$.
\item Poset width / partition into maximum number of chains: Duplicate each element
in $\{0,\ldots,n-1\}$, add edge $(u, n+v)$ for $u < v$. Edges in maximum matching in the
resulting bipartite graph correspond to chain edges. Width is n - max matching.
For weighted nodes, duplicate elements so they form an antichain.
\item Erdős–Gallai theorem: A sequence of non-negative integers $d_1\geq\cdots\geq d_n$ can be represented as the degree sequence of a finite simple graph on $n$ vertices if and only if $d_1+\cdots+d_n$ is even and $\sum^{k}_{i=1}d_i\leq k(k-1)+ \sum^n_{i=k+1} \min(d_i,k) \ \forall\ 1 \leq k \leq n$

\end{itemize}



\end{document}
